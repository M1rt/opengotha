/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package info.vannier.gotha;

import net.miginfocom.swing.MigLayout;
import ru.gofederation.gotha.model.Game;
import ru.gofederation.gotha.util.GothaLocale;

import javax.swing.JCheckBox;
import javax.swing.JOptionPane;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author Luc Vannier
 */
public class JFrDiscardRounds extends javax.swing.JFrame {
    private GothaLocale locale = GothaLocale.getCurrentLocale();

    private static final long REFRESH_DELAY = 2000;
    private long lastComponentsUpdateTime = 0;

    private TournamentInterface tournament;

    /**
     * Creates new form JFrDiscardRounds
     */
    public JFrDiscardRounds(TournamentInterface tournament) throws RemoteException {
        this.tournament = tournament;

        initComponents();
        customInitComponents();
        setupRefreshTimer();
    }

    private volatile boolean running = true;
    javax.swing.Timer timer = null;
    private void setupRefreshTimer() {
        ActionListener taskPerformer;
        taskPerformer = new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent evt) {
                if (!running){
                    timer.stop();
                }
                try {
                    if (tournament.getLastTournamentModificationTime() > lastComponentsUpdateTime) {
                        updateAllViews();
                    }
                } catch (RemoteException ex) {
                    Logger.getLogger(JFrGamesResults.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        };
        timer = new javax.swing.Timer((int) REFRESH_DELAY, taskPerformer);
        timer.start();
    }


    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    private void initComponents() {

        btnClose = new javax.swing.JButton();
        btnHelp = new javax.swing.JButton();
        pnlRoundsToKeep = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        ckbRemoveNotImpliedPlayers = new javax.swing.JCheckBox();
        ckbShiftRounds = new javax.swing.JCheckBox();
        btnDiscardRounds = new javax.swing.JButton();
        jLabel3 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
        setResizable(false);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });
        getContentPane().setLayout(new MigLayout("flowy, insets dialog", "push[]unrel[]push", "push[][][]unrel[]unrel[]push"));

        jLabel1.setFont(jLabel1.getFont().deriveFont(Font.ITALIC));
        jLabel1.setText(locale.getString("tournament.discard_rounds.help"));
        getContentPane().add(jLabel1, "split 2, growy 100");

        jLabel3.setText(locale.getString("tournament.discard_rounds.after"));
        getContentPane().add(jLabel3);

        ckbRemoveNotImpliedPlayers.setSelected(false);
        ckbRemoveNotImpliedPlayers.setText(locale.getString("tournament.discard_rounds.remove_players"));
        getContentPane().add(ckbRemoveNotImpliedPlayers, "gapleft indent, spanx");

        ckbShiftRounds.setSelected(true);
        ckbShiftRounds.setText(locale.getString("tournament.discard_rounds.shift_rounds"));
        getContentPane().add(ckbShiftRounds, "gapleft indent, spanx");

        btnDiscardRounds.setText(locale.getString("tournament.discard_rounds.btn_discard"));
        btnDiscardRounds.addActionListener(this::btnDiscardRoundsActionPerformed);
        getContentPane().add(btnDiscardRounds, "growx, spanx");

        btnClose.setText(locale.getString("btn.close"));
        btnClose.addActionListener(this::btnCloseActionPerformed);
        getContentPane().add(btnClose, "split 2, span, flowx, tag cancel");

        btnHelp.setIcon(new javax.swing.ImageIcon(getClass().getResource("/info/vannier/gotha/gothalogo16.jpg")));
        btnHelp.setText(locale.getString("btn.help"));
        btnHelp.addActionListener(this::btnHelpActionPerformed);
        getContentPane().add(btnHelp, "tag help, wrap");

        pnlRoundsToKeep.setBorder(javax.swing.BorderFactory.createTitledBorder(locale.getString("tournament.discard_rounds.keep")));
        pnlRoundsToKeep.setLayout(new MigLayout("wrap 5"));
        getContentPane().add(pnlRoundsToKeep, "ax right");

        pack();
    }

    private void btnCloseActionPerformed(java.awt.event.ActionEvent evt) {
        cleanClose();
    }

    private void cleanClose(){
        running = false;
        dispose();
    }

    private void btnHelpActionPerformed(java.awt.event.ActionEvent evt) {
//        JOptionPane.showMessageDialog(this, " This help will be available shortly");
        Gotha.displayGothaHelp("Discard rounds frame");
    }

    private void btnDiscardRoundsActionPerformed(java.awt.event.ActionEvent evt) {
        boolean[] bRoundsToKeep = new boolean[Gotha.MAX_NUMBER_OF_ROUNDS];
        for (int r = 0; r < Gotha.MAX_NUMBER_OF_ROUNDS; r++){
            bRoundsToKeep[r] = this.tabCkbRoundsToKeep[r].isSelected();
        }

        int nbDiscardedRounds = 0;
        int nbRemovedGames = 0;
        int nbRemovedByes = 0;
        int nbRemovedPlayers = 0;
        int nbShiftedRounds = 0;

        int nbRounds = Gotha.MAX_NUMBER_OF_ROUNDS;
            try {
                nbRounds = tournament.getTournamentParameterSet().getGeneralParameterSet().getNumberOfRounds();
            } catch (RemoteException ex) {
                Logger.getLogger(JFrDiscardRounds.class.getName()).log(Level.SEVERE, null, ex);
            }

        // How many rounds to be discarded ?
        for (int r = 0; r < nbRounds; r++){
            if(!bRoundsToKeep[r]) nbDiscardedRounds++;
        }

        // Discard games from unchecked rounds
        ArrayList<Game> alGames = null;
        try {
            alGames = tournament.gamesList();
        } catch (RemoteException ex) {
            Logger.getLogger(JFrExperimentalTools.class.getName()).log(Level.SEVERE, null, ex);
        }

        for (Game g : alGames){
            int r = g.getBoard();
            if (!bRoundsToKeep[r]) {
                try {
                    tournament.removeGame(g);
                } catch (TournamentException ex) {
                    Logger.getLogger(JFrDiscardRounds.class.getName()).log(Level.SEVERE, null, ex);
                } catch (RemoteException ex) {
                    Logger.getLogger(JFrDiscardRounds.class.getName()).log(Level.SEVERE, null, ex);
                }
                nbRemovedGames++;
            }
        }
        // Unassign bye players
        for(int r = 0; r < Gotha.MAX_NUMBER_OF_ROUNDS; r++){
            if (!bRoundsToKeep[r]){
                try {
                    if (tournament.getByePlayer(r) != null){
                        tournament.unassignByePlayer(r);
                        nbRemovedByes++;
                    }
                } catch (RemoteException ex) {
                    Logger.getLogger(JFrDiscardRounds.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        }

        // If required, remove unimplied players
        if (this.ckbRemoveNotImpliedPlayers.isSelected()){
            ArrayList<Player> alP;
            try {
                alP = tournament.playersList();
                for (Player p : alP){
                    if(!tournament.isPlayerImplied(p)){
                        tournament.removePlayer(p);
                        nbRemovedPlayers++;
                    }
                }
            } catch (RemoteException ex) {
                Logger.getLogger(JFrDiscardRounds.class.getName()).log(Level.SEVERE, null, ex);
            } catch (TournamentException ex) {
                Logger.getLogger(JFrDiscardRounds.class.getName()).log(Level.SEVERE, null, ex);
            }
        }


        // If required, shift rounds
        if (this.ckbShiftRounds.isSelected()){
            // All games are shifted
            // All bye players are shifted
            // All participations are shifted

            int newNumberOfRounds = nbRounds;

            int newR = -1;
            for (int oldR = 0; oldR < nbRounds; oldR++){
                if(!bRoundsToKeep[oldR]) continue;
                newR++;
                if (newR == oldR) continue;
                ArrayList<Game> alG = null;
                try {
                    nbShiftedRounds++;
                    alG = tournament.gamesList(oldR);
                    for(Game g : alG){
                        tournament.setRoundNumber(g, newR);
                    }
                    Player p = tournament.getByePlayer(oldR);
                    tournament.setByePlayer(p, newR);
                    tournament.setByePlayer(null, oldR);
                } catch (RemoteException | TournamentException ex) {
                    Logger.getLogger(JFrDiscardRounds.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
            newNumberOfRounds = newR + 1;
            // Participation
            ArrayList<Player> alP = null;;
            try {
                alP = tournament.playersList();
            } catch (RemoteException ex) {
                Logger.getLogger(JFrDiscardRounds.class.getName()).log(Level.SEVERE, null, ex);
            }
            for (Player p: alP){
                boolean[] bPart = p.getParticipating();
                newR = -1;
                for (int oldR = 0; oldR < nbRounds; oldR++){
                    if(!bRoundsToKeep[oldR]) continue;
                    newR++;
                    if (newR == oldR) continue;
                    bPart[newR] = bPart[oldR];
                    bPart[oldR] = true;
                }
                p.setParticipating(bPart);
                try {
                    tournament.modifyPlayer(p, p);
                } catch (TournamentException ex) {
                    Logger.getLogger(JFrDiscardRounds.class.getName()).log(Level.SEVERE, null, ex);
                } catch (RemoteException ex) {
                    Logger.getLogger(JFrDiscardRounds.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
            try {
                tournament.getTournamentParameterSet().getGeneralParameterSet().setNumberOfRounds(newNumberOfRounds);
            } catch (RemoteException ex) {
                Logger.getLogger(JFrDiscardRounds.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        // Reset check boxes selection
        for (int i = 0; i < Gotha.MAX_NUMBER_OF_ROUNDS; i++) {
            tabCkbRoundsToKeep[i].setSelected(true);
        }

        tournamentChanged();
        String report = locale.format("tournament.discard_rounds.report.rounds_discarded", nbDiscardedRounds) + "\n" +
                        locale.format("tournament.discard_rounds.report.games_removed", nbRemovedGames) + "\n" +
                        locale.format("tournament.discard_rounds.report.bye_unassigned", nbRemovedByes) + "\n" +
                        locale.format("tournament.discard_rounds.report.players_removed", nbRemovedPlayers) + "\n" +
                        locale.format("tournament.discard_rounds.report.rounds_shifted", nbShiftedRounds);
        JOptionPane.showMessageDialog(this, report);

    }

    private void formWindowClosing(java.awt.event.WindowEvent evt) {
        cleanClose();
    }

    private void customInitComponents()throws RemoteException{
        tabCkbRoundsToKeep = new JCheckBox[Gotha.MAX_NUMBER_OF_ROUNDS];
        Font font = null;
        for (int i = 0; i < Gotha.MAX_NUMBER_OF_ROUNDS; i++) {
            tabCkbRoundsToKeep[i] = new JCheckBox();
            tabCkbRoundsToKeep[i].setText("" + (i + 1));
            if (null == font) {
                font = tabCkbRoundsToKeep[i].getFont();
                font = font.deriveFont(font.getSize() * 0.8f);
            }
            tabCkbRoundsToKeep[i].setFont(font);
            pnlRoundsToKeep.add(tabCkbRoundsToKeep[i], "hidemode 3, sg a");
            tabCkbRoundsToKeep[i].setSelected(true);
        }

        updateAllViews();
    }


    private void updateAllViews(){
        try {
            if (!tournament.isOpen()) cleanClose();
            this.lastComponentsUpdateTime = tournament.getCurrentTournamentTime();
            setTitle(locale.format("tournament.discard_rounds", tournament.getFullName()));
        } catch (RemoteException ex) {
            Logger.getLogger(JFrPlayersQuickCheck.class.getName()).log(Level.SEVERE, null, ex);
        }
        int nbRounds = Gotha.MAX_NUMBER_OF_ROUNDS;
        try {
            nbRounds = tournament.getTournamentParameterSet().getGeneralParameterSet().getNumberOfRounds();
        } catch (RemoteException ex) {
            Logger.getLogger(JFrDiscardRounds.class.getName()).log(Level.SEVERE, null, ex);
        }
        for (int i = 0; i < nbRounds; i++) {
            tabCkbRoundsToKeep[i].setVisible(true);
        }
        for (int i = nbRounds; i < Gotha.MAX_NUMBER_OF_ROUNDS; i++) {
            tabCkbRoundsToKeep[i].setVisible(false);
        }
        this.pnlRoundsToKeep.setSize(new Dimension(220, 30 + (nbRounds + 4) / 5 * 25));
    }

    private void tournamentChanged(){
        try {
            if (!tournament.isOpen()){
                cleanClose();
                return;
            }
            tournament.setLastTournamentModificationTime(tournament.getCurrentTournamentTime());
        } catch (RemoteException ex) {
            Logger.getLogger(JFrDiscardRounds.class.getName()).log(Level.SEVERE, null, ex);
        }


    updateAllViews();

}

    private javax.swing.JButton btnClose;
    private javax.swing.JButton btnDiscardRounds;
    private javax.swing.JButton btnHelp;
    private javax.swing.JCheckBox ckbRemoveNotImpliedPlayers;
    private javax.swing.JCheckBox ckbShiftRounds;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JPanel pnlRoundsToKeep;
    private javax.swing.JCheckBox[] tabCkbRoundsToKeep;
}
